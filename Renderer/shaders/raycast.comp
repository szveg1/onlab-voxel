#version 450
#extension GL_ARB_gpu_shader_int64: enable
precision highp float;

struct VoxelNode {
    uint childMask;
    uint refs;
    uint material;
    uint children[8];
};

uniform struct {
    mat4 rayDirMatrix;
    vec3 position;
} camera;

uniform uint treeDepth;
uniform bool visualizeSteps;

layout(std430, binding = 0) buffer VoxelNodes {
    VoxelNode nodes[];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba32f, binding = 1) uniform writeonly image2D image;

bool rayBoxIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) {
    vec3 invRayDir = 1.0 / (rayDir + vec3(1e-8));
    
    vec3 t1 = (boxMin - rayOrigin) * invRayDir;
    vec3 t2 = (boxMax - rayOrigin) * invRayDir;
    
    vec3 tMin = min(t1, t2);
    vec3 tMax = max(t1, t2);
    
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    
    return tNear <= tFar && tFar > 0.0;
}

float traverseOctree(vec3 p, vec3 rayDir, out uint material) {
    vec3 clampedP = clamp(p, vec3(0.001), vec3(0.999));
    
    if (distance(p, clampedP) > 0.01) {
        return 0.1;
    }
    
    uint nodeIndex = 0;
    float nodeSize = 1.0;
    vec3 nodeCenter = vec3(0.5);

    for(int depth = 0; depth < int(treeDepth); depth++) {
        VoxelNode node = nodes[nodeIndex];
        
        // childMask == 0 -> empty node
        if (node.childMask == 0u) {
            vec3 nodeMin = nodeCenter - vec3(nodeSize * 0.5);
            vec3 nodeMax = nodeCenter + vec3(nodeSize * 0.5);

            vec3 t1 = (nodeMin - clampedP) / (rayDir + vec3(1e-8));
            vec3 t2 = (nodeMax - clampedP) / (rayDir + vec3(1e-8));

            vec3 tMax = max(t1, t2);
            float exitDist = min(min(tMax.x, tMax.y), tMax.z);

            return max(exitDist * 0.9, 0.001);
        }

        uint octant = 0;
        octant |= (clampedP.x > nodeCenter.x) ? 1 : 0;
        octant |= (clampedP.y > nodeCenter.y) ? 2 : 0;
        octant |= (clampedP.z > nodeCenter.z) ? 4 : 0;

        uint childBit = 1u << octant;

        // leaf node
        if (depth == int(treeDepth) - 1 && (node.childMask & childBit) != 0) {
            material = node.material;
            return 0.0; // Found a voxel
        }

        // empty octant
        if ((node.childMask & childBit) == 0) {
            // Calculate boundaries of current octant
            vec3 octantMin = nodeCenter;
            vec3 octantMax = nodeCenter;
            
            if ((octant & 1) != 0) {
                octantMin.x = nodeCenter.x;
                octantMax.x = nodeCenter.x + nodeSize * 0.5;
            } else {
                octantMin.x = nodeCenter.x - nodeSize * 0.5;
                octantMax.x = nodeCenter.x;
            }
            
            if ((octant & 2) != 0) {
                octantMin.y = nodeCenter.y;
                octantMax.y = nodeCenter.y + nodeSize * 0.5;
            } else {
                octantMin.y = nodeCenter.y - nodeSize * 0.5;
                octantMax.y = nodeCenter.y;
            }
            
            if ((octant & 4) != 0) {
                octantMin.z = nodeCenter.z;
                octantMax.z = nodeCenter.z + nodeSize * 0.5;
            } else {
                octantMin.z = nodeCenter.z - nodeSize * 0.5;
                octantMax.z = nodeCenter.z;
            }

            vec3 t1 = (octantMin - clampedP) / (rayDir + vec3(1e-8));
            vec3 t2 = (octantMax - clampedP) / (rayDir + vec3(1e-8));

            vec3 tMax = max(t1, t2);
            float exitDist = min(min(tMax.x, tMax.y), tMax.z);
            
            return max(exitDist * 0.9, 0.001);
        }

        uint nextIndex = node.children[octant];
        if (nextIndex == 0u) {
            return 0.001; 
        }

        nodeIndex = nextIndex;
        nodeSize *= 0.5;
        nodeCenter += nodeSize * (vec3(
            (octant & 1) != 0 ? 0.5 : -0.5,
            (octant & 2) != 0 ? 0.5 : -0.5,
            (octant & 4) != 0 ? 0.5 : -0.5
        ));
    }
    
    // If we get here, we didn't find a voxel at the deepest level
    return 0.001; // Small step to continue searching
}

float saturate( float x ) { return clamp( x, 0.0, 1.0 ); }
vec3 saturate( vec3 x ) { return clamp( x, vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0) ); }

vec3 plasma_quintic( float x )
{
    x = saturate( x );
    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3
    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7
    return saturate( vec3(
        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),
        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),
        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) ) );
}

vec3 getColorFromMaterial(uint material) {
    uint redMask = 0xF800;
    uint greenMask = 0x7E0;
    uint blueMask = 0x1F;

    uint redValue = (material & redMask) >> 11;
    uint greenValue = (material & greenMask) >> 5;
    uint blueValue = (material & blueMask);

    float red = (redValue << 3) / 256.0f; 
    float green = (greenValue << 2) / 256.0f;
    float blue = (blueValue << 3) / 256.0f;

    return vec3(red, green, blue);
}

void main() {
    vec2 viewportSize = imageSize(image);
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(pixelCoord) / viewportSize) * 2.0 - 1.0;

    vec4 pixel = vec4(uv, 1, 1);
    vec4 rayDir = pixel * camera.rayDirMatrix;
    vec3 rayOrigin = camera.position;
    vec3 d = normalize(rayDir.xyz);

    vec3 worldMin = vec3(0.0);
    vec3 worldMax = vec3(1.0);
    
    float tNear, tFar;
    bool intersectsWorld = rayBoxIntersection(rayOrigin, d, worldMin, worldMax, tNear, tFar);
    
    if (!intersectsWorld) {
        imageStore(image, pixelCoord, vec4(0));
        return;
    }
    
    float tStart = max(tNear, 0.0);
    float tEnd = tFar;
    
    if (tStart >= tEnd) {
        imageStore(image, pixelCoord, vec4(0));
        return;
    }

    bool found = false;
    vec3 p = rayOrigin + d * tStart;
    int steps = 0;
    uint material;

    for (int i = 0; i < 1024; i++) {
        steps = i;
        
        if (any(lessThan(p, worldMin)) || any(greaterThan(p, worldMax))) {
            break;
        }
        
        float currentT = length(p - rayOrigin);
        
        if (currentT > tEnd) {
            break;
        }
        
        float stepSize = traverseOctree(p, d, material);
        
        if (stepSize == 0.0) {
            found = true;
            break;
        }
        
        p += d * stepSize;
    }

    if (found) {
        vec3 color; 
        if (visualizeSteps) {
            float steps_normalized = steps / 1024.0f;
            color = plasma_quintic(steps_normalized);        
        } else {
            color = getColorFromMaterial(material);
        }
        imageStore(image, pixelCoord, vec4(color, 1));
    } else {
        imageStore(image, pixelCoord, vec4(0));
    }
}
