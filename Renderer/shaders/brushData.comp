#version 450
#extension GL_ARB_gpu_shader_int64: enable
precision highp float;

struct VoxelNode {
    uint childMask;
    uint refs;
    uint material;
    uint children[8];
};

layout(std430, binding = 0) buffer VoxelNodes {
    VoxelNode nodes[];
};

uniform struct {
    mat4 rayDirMatrix;
    vec3 position;
} camera;

uniform uint treeDepth;

layout(std430, binding = 3) buffer BrushData {
    vec4 brushData; // .xyz = position, .w = hit flag
};

float traverseOctree(vec3 p, vec3 rayDir, out uint material) {
    const float epsilon = 1e-6;
    vec3 rayPos = p + rayDir * epsilon;
    
    uint nodeIndex = 0;
    float nodeSize = 1.0;
    vec3 nodeCenter = vec3(0.5);

    for(int depth = 0; depth < int(treeDepth); depth++) {
        VoxelNode node = nodes[nodeIndex];
        
        // Empty node check
        if (node.childMask == 0u) {
            vec3 nodeMin = nodeCenter - vec3(nodeSize * 0.5);
            vec3 nodeMax = nodeCenter + vec3(nodeSize * 0.5);

            float exitDist = 0.0;
            bool hasValidExit = false;
            
            for (int axis = 0; axis < 3; axis++) {
                float planeDist = rayDir[axis] > 0.0 ? 
                    (nodeMax[axis] - rayPos[axis]) / rayDir[axis] : 
                    (nodeMin[axis] - rayPos[axis]) / rayDir[axis];
                
                if (planeDist > 0.0) {
                    if (!hasValidExit || planeDist < exitDist) {
                        exitDist = planeDist;
                        hasValidExit = true;
                    }
                }
            }
            
            // Safeguard against numerical issues
            if (!hasValidExit) exitDist = nodeSize * 0.1;
            
            return max(exitDist * 0.95, nodeSize * 0.01);
        }

        // Rest of octant calculation remains the same
        uint octant = 0;
        octant |= (rayPos.x > nodeCenter.x) ? 1 : 0;
        octant |= (rayPos.y > nodeCenter.y) ? 2 : 0;
        octant |= (rayPos.z > nodeCenter.z) ? 4 : 0;

        uint childBit = 1u << octant;

        // Leaf node
        if (depth == int(treeDepth) - 1 && (node.childMask & childBit) != 0) {
            material = node.material;
            return 0.0; // Found a voxel
        }

        // empty octant
        if ((node.childMask & childBit) == 0) {
            // Calculate boundaries of current octant
            vec3 octantMin = nodeCenter;
            vec3 octantMax = nodeCenter;

            if ((octant & 1) != 0) {
                octantMin.x = nodeCenter.x;
                octantMax.x = nodeCenter.x + nodeSize * 0.5;
            } else {
                octantMin.x = nodeCenter.x - nodeSize * 0.5;
                octantMax.x = nodeCenter.x;
            }
            
            if ((octant & 2) != 0) {
                octantMin.y = nodeCenter.y;
                octantMax.y = nodeCenter.y + nodeSize * 0.5;
            } else {
                octantMin.y = nodeCenter.y - nodeSize * 0.5;
                octantMax.y = nodeCenter.y;
            }
            
            if ((octant & 4) != 0) {
                octantMin.z = nodeCenter.z;
                octantMax.z = nodeCenter.z + nodeSize * 0.5;
            } else {
                octantMin.z = nodeCenter.z - nodeSize * 0.5;
                octantMax.z = nodeCenter.z;
            }

            vec3 t1 = (octantMin - rayPos) / (rayDir + vec3(1e-8));
            vec3 t2 = (octantMax - rayPos) / (rayDir + vec3(1e-8));

            vec3 tMax = max(t1, t2);
            float exitDist = min(min(tMax.x, tMax.y), tMax.z);
            
            return max(exitDist * 0.95, nodeSize * 0.01);
        }

        uint nextIndex = node.children[octant];
        if (nextIndex == 0u) {
            return nodeSize * 0.01;
        }

        nodeIndex = nextIndex;
        nodeSize *= 0.5;
        nodeCenter += nodeSize * (vec3(
            (octant & 1) != 0 ? 0.5 : -0.5,
            (octant & 2) != 0 ? 0.5 : -0.5,
            (octant & 4) != 0 ? 0.5 : -0.5
        ));
    }
    
    return nodeSize * 0.01;
}

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
    vec4 rayDir = vec4(0.0, 0.0, 1.0, 1.0) * camera.rayDirMatrix;
    vec3 d = normalize(rayDir.xyz);
    vec3 p = camera.position;

    brushData = vec4(0.0, 0.0, 0.0, -1.0);

    for (int i = 0; i < 512; i++) {
        if (any(lessThan(p, vec3(0.0))) || any(greaterThan(p, vec3(1.0)))) {
            return;
        }
        
        uint material;
        float stepSize = traverseOctree(p, d, material);

        if (stepSize == 0.0) {
            vec3 relPos = fract(p * pow(2.0, float(treeDepth-1))) - 0.5;
            vec3 absPos = abs(relPos);
            vec3 hitNormal;
            if (absPos.x > absPos.y && absPos.x > absPos.z) {
                hitNormal = vec3(sign(relPos.x), 0.0, 0.0);
            } else if (absPos.y > absPos.z) {
                hitNormal = vec3(0.0, sign(relPos.y), 0.0);
            } else {
                hitNormal = vec3(0.0, 0.0, sign(relPos.z));
            }

            float voxelSize = 1.0 / pow(2.0, float(treeDepth - 1));
            vec3 center = p + hitNormal * voxelSize * 0.6;

            brushData = vec4(center, 1.0);
            return;
        }
        p += d * stepSize;
    }
}