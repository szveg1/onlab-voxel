#version 450
#extension GL_ARB_gpu_shader_int64: enable
precision highp float;

struct VoxelNode {
    uint childMask;
    uint refs;
    uint material;
    uint children[8];
};

uniform int editAction; // 0 = DELETE, 1 = ADD
uniform uint editMaterial;
uniform vec3 brushCenter;
uniform float brushSize;
uniform uint treeDepth;
uniform ivec3 brushGridBase;

layout(std430, binding = 0) buffer VoxelNodes {
    VoxelNode nodes[];
};


layout(binding = 1, offset = 0) uniform atomic_uint nodeCounter;


void modifyOctree(vec3 targetPos) {
    uint nodeIndex = 0;
    float nodeSize = 1.0;
    vec3 nodeCenter = vec3(0.5);

    for (int depth = 0; depth < int(treeDepth) - 1; depth++) {
        uint octant = 0;
        if (targetPos.x > nodeCenter.x) octant |= 1;
        if (targetPos.y > nodeCenter.y) octant |= 2;
        if (targetPos.z > nodeCenter.z) octant |= 4;

        VoxelNode parentNode = nodes[nodeIndex];
        uint childBit = 1u << octant;

        if ((parentNode.childMask & childBit) == 0) {
        if (editAction == 1) {
            uint newNodeIndex = atomicCounterIncrement(nodeCounter);
            
            if (newNodeIndex >= nodes.length()) { return; }

                nodes[newNodeIndex].childMask = 0u;
                nodes[newNodeIndex].material = 0u;
                for(int i=0; i<8; i++) nodes[newNodeIndex].children[i] = 0u;
     
                nodes[nodeIndex].children[octant] = newNodeIndex;
                nodes[nodeIndex].childMask |= childBit;
                
                nodeIndex = newNodeIndex;
            } else {
                return;
            }
        } else {
            nodeIndex = parentNode.children[octant];
        }

        nodeSize *= 0.5;
        vec3 offsetDir = vec3(
            (octant & 1) != 0 ? 0.5 : -0.5,
            (octant & 2) != 0 ? 0.5 : -0.5,
            (octant & 4) != 0 ? 0.5 : -0.5
        );
        nodeCenter += nodeSize * offsetDir;
    }

    uint leafOctant = 0;
    if (targetPos.x > nodeCenter.x) leafOctant |= 1;
    if (targetPos.y > nodeCenter.y) leafOctant |= 2;
    if (targetPos.z > nodeCenter.z) leafOctant |= 4;

    uint leafBit = 1u << leafOctant;

    if (editAction == 1) {
        nodes[nodeIndex].childMask |= leafBit;
        nodes[nodeIndex].material = editMaterial; 
    } else {
        nodes[nodeIndex].childMask &= ~leafBit;
    }
}

layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

void main() {
    float voxelSize = 1.0 / pow(2.0, float(treeDepth - 1));

    ivec3 voxelGridCoord = ivec3(gl_GlobalInvocationID);

    vec3 voxelWorldPos = (vec3(brushGridBase) + vec3(voxelGridCoord)) * voxelSize + (voxelSize * 0.5);

    if (distance(voxelWorldPos, brushCenter) <= brushSize) {
        if (all(greaterThanEqual(voxelWorldPos, vec3(0.0))) && all(lessThan(voxelWorldPos, vec3(1.0)))) {
            modifyOctree(voxelWorldPos);
        }
    }
}