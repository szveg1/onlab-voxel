#version 450
#extension GL_ARB_gpu_shader_int64: enable
precision highp float;

struct VoxelNode {
    uint childMask;
    uint refs;
    uint material;
    uint children[8];
};

uniform struct {
    mat4 rayDirMatrix;
    vec3 position;
} camera;

uniform uint treeDepth;
uniform bool visualizeSteps;
uniform float brushSize;
uniform vec3 brushCenter;
uniform vec3 brushColor;
uniform bool selectingBox;
uniform vec3 firstCorner;

layout(std430, binding = 0) buffer VoxelNodes {
    VoxelNode nodes[];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba32f, binding = 1) uniform writeonly image2D image;


bool rayBoxIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) {
    vec3 invRayDir = 1.0 / rayDir;
    
    bvec3 sign = lessThan(invRayDir, vec3(0.0));
    vec3 bbox1 = mix(boxMin, boxMax, sign);
    vec3 bbox2 = mix(boxMax, boxMin, sign);
    
    vec3 tMin = (bbox1 - rayOrigin) * invRayDir;
    vec3 tMax = (bbox2 - rayOrigin) * invRayDir;
    
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    
    return tNear <= tFar && tFar > 0.0;
}

float traverseOctree(vec3 p, vec3 rayDir, out uint material) {
    const float epsilon = 1e-6;
    vec3 rayPos = p + rayDir * epsilon;
    
    uint nodeIndex = 0;
    float nodeSize = 1.0;
    vec3 nodeCenter = vec3(0.5);

    for(int depth = 0; depth < int(treeDepth); depth++) {
        VoxelNode node = nodes[nodeIndex];
        
        // fully solid node
        if (node.childMask == 0xFFu && node.children[0] == 0u) {
            material = node.material;
            return 0.0;
        }

        // Empty node check
        if (node.childMask == 0u) {
            vec3 nodeMin = nodeCenter - vec3(nodeSize * 0.5);
            vec3 nodeMax = nodeCenter + vec3(nodeSize * 0.5);

            float exitDist = 0.0;
            bool hasValidExit = false;
            
            for (int axis = 0; axis < 3; axis++) {
                float planeDist = rayDir[axis] > 0.0 ? 
                    (nodeMax[axis] - rayPos[axis]) / rayDir[axis] : 
                    (nodeMin[axis] - rayPos[axis]) / rayDir[axis];
                
                if (planeDist > 0.0) {
                    if (!hasValidExit || planeDist < exitDist) {
                        exitDist = planeDist;
                        hasValidExit = true;
                    }
                }
            }
            
            // Safeguard against numerical issues
            if (!hasValidExit) exitDist = nodeSize * 0.1;
            
            return max(exitDist * 0.95, nodeSize * 0.01);
        }

        uint octant = 0;
        octant |= (rayPos.x > nodeCenter.x) ? 1 : 0;
        octant |= (rayPos.y > nodeCenter.y) ? 2 : 0;
        octant |= (rayPos.z > nodeCenter.z) ? 4 : 0;

        uint childBit = 1u << octant;

        // Leaf node
        if (depth == int(treeDepth) - 1 && (node.childMask & childBit) != 0) {
            material = node.material;
            return 0.0; // Found a voxel
        }

        // empty octant
        if ((node.childMask & childBit) == 0) {
            // Calculate boundaries of current octant
            vec3 octantMin = nodeCenter;
            vec3 octantMax = nodeCenter;

            if ((octant & 1) != 0) {
                octantMin.x = nodeCenter.x;
                octantMax.x = nodeCenter.x + nodeSize * 0.5;
            } else {
                octantMin.x = nodeCenter.x - nodeSize * 0.5;
                octantMax.x = nodeCenter.x;
            }
            
            if ((octant & 2) != 0) {
                octantMin.y = nodeCenter.y;
                octantMax.y = nodeCenter.y + nodeSize * 0.5;
            } else {
                octantMin.y = nodeCenter.y - nodeSize * 0.5;
                octantMax.y = nodeCenter.y;
            }
            
            if ((octant & 4) != 0) {
                octantMin.z = nodeCenter.z;
                octantMax.z = nodeCenter.z + nodeSize * 0.5;
            } else {
                octantMin.z = nodeCenter.z - nodeSize * 0.5;
                octantMax.z = nodeCenter.z;
            }

            vec3 t1 = (octantMin - rayPos) / (rayDir + vec3(1e-8));
            vec3 t2 = (octantMax - rayPos) / (rayDir + vec3(1e-8));

            vec3 tMax = max(t1, t2);
            float exitDist = min(min(tMax.x, tMax.y), tMax.z);
            
            return max(exitDist * 0.95, nodeSize * 0.01);
        }

        uint nextIndex = node.children[octant];
        if (nextIndex == 0u) {
            return nodeSize * 0.01;
        }

        nodeIndex = nextIndex;
        nodeSize *= 0.5;
        nodeCenter += nodeSize * (vec3(
            (octant & 1) != 0 ? 0.5 : -0.5,
            (octant & 2) != 0 ? 0.5 : -0.5,
            (octant & 4) != 0 ? 0.5 : -0.5
        ));
    }
    
    return nodeSize * 0.01;
}

float intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b*b - 4*a*c;
    if (discriminant < 0.0) {
        return -1.0;
    }
    
    float t = (-b - sqrt(discriminant)) / (2.0 * a);
    if (t > 0.0) {
        return t;
    }
    
    t = (-b + sqrt(discriminant)) / (2.0 * a);
    if (t > 0.0) {
        return t;
    }

    return -1.0;
}

float saturate( float x ) { return clamp( x, 0.0, 1.0 ); }
vec3 saturate( vec3 x ) { return clamp( x, vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0) ); }

vec3 plasma_quintic( float x )
{
    x = saturate( x );
    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3
    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7
    return saturate( vec3(
        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),
        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),
        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) ) );
}

vec3 getColorFromMaterial(uint material) {
    uint redMask = 0xF800;
    uint greenMask = 0x7E0;
    uint blueMask = 0x1F;

    uint redValue = (material & redMask) >> 11;
    uint greenValue = (material & greenMask) >> 5;
    uint blueValue = (material & blueMask);

    float red = (redValue << 3) / 256.0f; 
    float green = (greenValue << 2) / 256.0f;
    float blue = (blueValue << 3) / 256.0f;

    return vec3(red, green, blue);
}

void main() {
    vec2 viewportSize = imageSize(image);
    vec2 center = viewportSize * 0.5;
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(pixelCoord) / viewportSize) * 2.0 - 1.0;

    vec4 pixel = vec4(uv, 1, 1);
    vec4 rayDir = pixel * camera.rayDirMatrix;
    vec3 rayOrigin = camera.position;
    vec3 d = normalize(rayDir.xyz);

    vec3 worldMin = vec3(0.0);
    vec3 worldMax = vec3(1.0);
    
    float tNear, tFar;
    bool intersectsWorld = rayBoxIntersection(rayOrigin, d, worldMin, worldMax, tNear, tFar);
    
    if (!intersectsWorld) {
        imageStore(image, pixelCoord, vec4(0));
        return;
    }

    float tStart = max(tNear, 0.0);
    float tEnd = tFar;
    
    if (tStart >= tEnd) {
        imageStore(image, pixelCoord, vec4(0));
        return;
    }
    
    bool found = false;
    vec3 p = rayOrigin + d * (tStart + 1e-5);
    int steps = 0;
    uint material;
    vec3 hitNormal;

    for (int i = 0; i < 1024; i++) {
        steps = i;
        
        if (any(lessThan(p, worldMin)) || any(greaterThan(p, worldMax))) {
            break;
        }
        
        float currentT = length(p - rayOrigin);
        
        if (currentT > tEnd) {
            break;
        }
         
        float stepSize = traverseOctree(p, d, material);
        
        if (stepSize == 0.0) {
            found = true;
            
            vec3 relPos = fract(p) - 0.5;
            vec3 absPos = abs(relPos);
            
            if (absPos.x > absPos.y && absPos.x > absPos.z) {
                hitNormal = vec3(sign(relPos.x), 0.0, 0.0);
            } else if (absPos.y > absPos.z) {
                hitNormal = vec3(0.0, sign(relPos.y), 0.0);
            } else {
                hitNormal = vec3(0.0, 0.0, sign(relPos.z));
            }
            
            break;
        }
        
        p += d * stepSize;
    }

    vec3 sceneColor = vec3(0.0);
    float sceneDepth = 1.0/0.0;

    if (found) {
        if (visualizeSteps) {
            float steps_normalized = float(steps) / 128.0f;
            sceneColor = plasma_quintic(steps_normalized);
        } else {
            sceneColor = getColorFromMaterial(material);
        }
        sceneDepth = length(p - rayOrigin);
    }
    
    vec3 finalColor = sceneColor;

    if (selectingBox) {
        vec3 boxMin = min(brushCenter, firstCorner);
        vec3 boxMax = max(brushCenter, firstCorner);
        
        float tNearBox, tFarBox;
        bool intersectsBox = rayBoxIntersection(rayOrigin, d, boxMin, boxMax, tNearBox, tFarBox);
        if (intersectsBox && tNearBox < sceneDepth) {
            vec3 hitPoint = rayOrigin + d * max(0.0, tNearBox);
            
            const float threshold = 0.001; 
            
            bool isCloseToPlane = 
                (abs(hitPoint.x - boxMin.x) < threshold) || (abs(hitPoint.x - boxMax.x) < threshold) ||
                (abs(hitPoint.y - boxMin.y) < threshold) || (abs(hitPoint.y - boxMax.y) < threshold) ||
                (abs(hitPoint.z - boxMin.z) < threshold) || (abs(hitPoint.z - boxMax.z) < threshold);

            if (isCloseToPlane) {
                float ghostAlpha = 0.6;
                vec3 boxColor = vec3(1.0, 1.0, 0.0);
                finalColor = mix(finalColor, boxColor, ghostAlpha);
            }
        }
    } else if (brushCenter.x > -990.0 && !selectingBox) {
        float brushDepth = intersectSphere(rayOrigin, d, brushCenter, brushSize);

        if (brushDepth > 0.0 && brushDepth < sceneDepth) {
            float ghostAlpha = 0.4;
            finalColor = mix(finalColor, brushColor, ghostAlpha);
        }
    }

    imageStore(image, pixelCoord, vec4(finalColor, 1.0));
}