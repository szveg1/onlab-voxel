#version 450
#extension GL_ARB_gpu_shader_int64: enable
precision highp float;

struct VoxelNode {
    uint childMask;
    uint refs;
    uint material;
    uint children[8];
};

uniform struct {
    mat4 rayDirMatrix;
    vec3 position;
} camera;

uniform uint treeDepth;
uniform bool visualizeSteps;
uniform float brushSize;

layout(std430, binding = 0) buffer VoxelNodes {
    VoxelNode nodes[];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba32f, binding = 1) uniform writeonly image2D image;


bool rayBoxIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) {
    vec3 invRayDir = 1.0 / rayDir;
    
    bvec3 sign = lessThan(invRayDir, vec3(0.0));
    vec3 bbox1 = mix(boxMin, boxMax, sign);
    vec3 bbox2 = mix(boxMax, boxMin, sign);
    
    vec3 tMin = (bbox1 - rayOrigin) * invRayDir;
    vec3 tMax = (bbox2 - rayOrigin) * invRayDir;
    
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    
    return tNear <= tFar && tFar > 0.0;
}

float traverseOctree(vec3 p, vec3 rayDir, out uint material) {
    const float epsilon = 1e-6;
    vec3 rayPos = p + rayDir * epsilon;
    
    uint nodeIndex = 0;
    float nodeSize = 1.0;
    vec3 nodeCenter = vec3(0.5);

    for(int depth = 0; depth < int(treeDepth); depth++) {
        VoxelNode node = nodes[nodeIndex];
        
        // Empty node check
        if (node.childMask == 0u) {
            vec3 nodeMin = nodeCenter - vec3(nodeSize * 0.5);
            vec3 nodeMax = nodeCenter + vec3(nodeSize * 0.5);

            float exitDist = 0.0;
            bool hasValidExit = false;
            
            for (int axis = 0; axis < 3; axis++) {
                float planeDist = rayDir[axis] > 0.0 ? 
                    (nodeMax[axis] - rayPos[axis]) / rayDir[axis] : 
                    (nodeMin[axis] - rayPos[axis]) / rayDir[axis];
                
                if (planeDist > 0.0) {
                    if (!hasValidExit || planeDist < exitDist) {
                        exitDist = planeDist;
                        hasValidExit = true;
                    }
                }
            }
            
            // Safeguard against numerical issues
            if (!hasValidExit) exitDist = nodeSize * 0.1;
            
            return max(exitDist * 0.95, nodeSize * 0.01);
        }

        // Rest of octant calculation remains the same
        uint octant = 0;
        octant |= (rayPos.x > nodeCenter.x) ? 1 : 0;
        octant |= (rayPos.y > nodeCenter.y) ? 2 : 0;
        octant |= (rayPos.z > nodeCenter.z) ? 4 : 0;

        uint childBit = 1u << octant;

        // Leaf node
        if (depth == int(treeDepth) - 1 && (node.childMask & childBit) != 0) {
            material = node.material;
            return 0.0; // Found a voxel
        }

        // empty octant
        if ((node.childMask & childBit) == 0) {
            // Calculate boundaries of current octant
            vec3 octantMin = nodeCenter;
            vec3 octantMax = nodeCenter;

            if ((octant & 1) != 0) {
                octantMin.x = nodeCenter.x;
                octantMax.x = nodeCenter.x + nodeSize * 0.5;
            } else {
                octantMin.x = nodeCenter.x - nodeSize * 0.5;
                octantMax.x = nodeCenter.x;
            }
            
            if ((octant & 2) != 0) {
                octantMin.y = nodeCenter.y;
                octantMax.y = nodeCenter.y + nodeSize * 0.5;
            } else {
                octantMin.y = nodeCenter.y - nodeSize * 0.5;
                octantMax.y = nodeCenter.y;
            }
            
            if ((octant & 4) != 0) {
                octantMin.z = nodeCenter.z;
                octantMax.z = nodeCenter.z + nodeSize * 0.5;
            } else {
                octantMin.z = nodeCenter.z - nodeSize * 0.5;
                octantMax.z = nodeCenter.z;
            }

            vec3 t1 = (octantMin - rayPos) / (rayDir + vec3(1e-8));
            vec3 t2 = (octantMax - rayPos) / (rayDir + vec3(1e-8));

            vec3 tMax = max(t1, t2);
            float exitDist = min(min(tMax.x, tMax.y), tMax.z);
            
            return max(exitDist * 0.95, nodeSize * 0.01);
        }

        uint nextIndex = node.children[octant];
        if (nextIndex == 0u) {
            return nodeSize * 0.01;
        }

        nodeIndex = nextIndex;
        nodeSize *= 0.5;
        nodeCenter += nodeSize * (vec3(
            (octant & 1) != 0 ? 0.5 : -0.5,
            (octant & 2) != 0 ? 0.5 : -0.5,
            (octant & 4) != 0 ? 0.5 : -0.5
        ));
    }
    
    return nodeSize * 0.01;
}

vec3 getBrushCenter() {
    vec2 centerUV = vec2(0.0, 0.0);
    vec4 centerPixel = vec4(centerUV, 1, 1);
    vec4 centerRayDir = centerPixel * camera.rayDirMatrix;
    vec3 centerD = normalize(centerRayDir.xyz);
    
    vec3 centerP = camera.position + centerD * 1e-5;
    uint material;
    
    for (int i = 0; i < 32; i++) {
        if (any(lessThan(centerP, vec3(0.0))) || any(greaterThan(centerP, vec3(1.0)))) {
            break;
        }
        
        float stepSize = traverseOctree(centerP, centerD, material);
        
        if (stepSize == 0.0) {
            vec3 relPos = fract(centerP) - 0.5;
            vec3 absPos = abs(relPos);
            vec3 centerNormal;
            
            if (absPos.x > absPos.y && absPos.x > absPos.z) {
                centerNormal = vec3(sign(relPos.x), 0.0, 0.0);
            } else if (absPos.y > absPos.z) {
                centerNormal = vec3(0.0, sign(relPos.y), 0.0);
            } else {
                centerNormal = vec3(0.0, 0.0, sign(relPos.z));
            }
            
            float voxelSize = 1.0 / pow(2.0, float(treeDepth - 1));
            return centerP + centerNormal * voxelSize * 0.6;
        }
        
        centerP += centerD * stepSize;
    }
    
    return vec3(-999.0);
}

float saturate( float x ) { return clamp( x, 0.0, 1.0 ); }
vec3 saturate( vec3 x ) { return clamp( x, vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0) ); }

vec3 plasma_quintic( float x )
{
    x = saturate( x );
    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3
    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7
    return saturate( vec3(
        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),
        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),
        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) ) );
}

vec3 getColorFromMaterial(uint material) {
    uint redMask = 0xF800;
    uint greenMask = 0x7E0;
    uint blueMask = 0x1F;

    uint redValue = (material & redMask) >> 11;
    uint greenValue = (material & greenMask) >> 5;
    uint blueValue = (material & blueMask);

    float red = (redValue << 3) / 256.0f; 
    float green = (greenValue << 2) / 256.0f;
    float blue = (blueValue << 3) / 256.0f;

    return vec3(red, green, blue);
}

void main() {
    vec2 viewportSize = imageSize(image);
    vec2 center = viewportSize * 0.5;
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (vec2(pixelCoord) / viewportSize) * 2.0 - 1.0;

    vec4 pixel = vec4(uv, 1, 1);
    vec4 rayDir = pixel * camera.rayDirMatrix;
    vec3 rayOrigin = camera.position;
    vec3 d = normalize(rayDir.xyz);

    vec3 worldMin = vec3(0.0);
    vec3 worldMax = vec3(1.0);
    
    float tNear, tFar;
    bool intersectsWorld = rayBoxIntersection(rayOrigin, d, worldMin, worldMax, tNear, tFar);
    
    if (!intersectsWorld) {
        imageStore(image, pixelCoord, vec4(0));
        return;
    }

    float tStart = max(tNear, 0.0);
    float tEnd = tFar;
    
    if (tStart >= tEnd) {
        imageStore(image, pixelCoord, vec4(0));
        return;
    }
    
    bool found = false;
    vec3 p = rayOrigin + d * (tStart + 1e-5);
    int steps = 0;
    uint material;
    vec3 hitNormal;

    for (int i = 0; i < 1024; i++) {
        steps = i;
        
        if (any(lessThan(p, worldMin)) || any(greaterThan(p, worldMax))) {
            break;
        }
        
        float currentT = length(p - rayOrigin);
        
        if (currentT > tEnd) {
            break;
        }
         
        float stepSize = traverseOctree(p, d, material);
        
        if (stepSize == 0.0) {
            found = true;
            
            vec3 relPos = fract(p) - 0.5;
            vec3 absPos = abs(relPos);
            
            if (absPos.x > absPos.y && absPos.x > absPos.z) {
                hitNormal = vec3(sign(relPos.x), 0.0, 0.0);
            } else if (absPos.y > absPos.z) {
                hitNormal = vec3(0.0, sign(relPos.y), 0.0);
            } else {
                hitNormal = vec3(0.0, 0.0, sign(relPos.z));
            }
            
            break;
        }
        
        p += d * stepSize;
    }

    if (found) {
    vec3 color; 
    if (visualizeSteps) {
        float steps_normalized = steps / 1024.0f;
        color = plasma_quintic(steps_normalized);        
    } else {
        color = getColorFromMaterial(material);
        
        if (true) {
            vec3 brushCenter = getBrushCenter();
            
            if (brushCenter.x != -999.0) {
                float distanceToBrush = length(p - brushCenter);
                
                if (distanceToBrush <= brushSize) {
                    float intensity = 1.0 - (distanceToBrush / brushSize);
                    intensity = smoothstep(0.0, 1.0, intensity);
                    
                    vec3 highlightColor = vec3(0.3, 0.8, 1.0);
                    
                    color = mix(color, highlightColor, intensity * 0.6);
                }
            }
        }
        
        // Apply lighting
        // color = applyLighting(color, hitNormal, -d);
    }
        imageStore(image, pixelCoord, vec4(color, 1));
    } else {
        imageStore(image, pixelCoord, vec4(0));
    }
}